@page "/The_Eye"
@using Microsoft.ML
<!-- @using System.Drawing -->
@inject IJSRuntime JS

<PageTitle>The Eye</PageTitle>

<h1>Go on, just try and draw a 1-digit number</h1>

<div tabindex="0" @onclick="CanvasClick">
    <BECanvas Width="@canvasDimensionLength" Height="@canvasDimensionLength" @ref="_canvasReference"></BECanvas>

    <p>You clicked (x: @mouseX, y: @mouseY)</p>
</div>

<button @onclick="ExportImage">Export Image</button>
<button @onclick="PredictImage">Predict Image</button>

<p>pixel row length @pixelRowLength</p>
<p>pixel array length @pixelArrayDims</p>
<p>interesting pixel count @nonMinMaxPixelCount</p>
<p>I think that's a @Prediction</p>

<p>@dataURL</p>

@code {
    private int imageDimensionLength = 28;

    private int canvasDimensionLength => imageDimensionLength + 2;

    private int pixelArrayDims = -1;

    private int pixelRowLength = -1;

    private int nonMinMaxPixelCount = -1;

    private double? mouseX;

    private double? mouseXCache;

    private double? mouseY;

    private double? mouseYCache;

    private string dataURL;

    private const string imageLocation = "images/canvasImage.png";
    
    private const string csvLocation = "images/canvasImage.csv";

    private Canvas2DContext _context;

    protected BECanvasComponent _canvasReference;

    protected bool CanvasLoaded = false;

    protected ITransformer? Transformer => NoughtToNine.TheModel.Transformer;

    protected MLContext? MLContext => NoughtToNine.TheModel.mlContext;

    protected UInt32 Prediction = 10;

    protected async Task PredictImage(){
        Image image = SixLabors.ImageSharp.Image.Load(new StreamReader(imageLocation).BaseStream);

        List<float> inputList = new();

        int rowcount = 1;
        image.Mutate(c => c.ProcessPixelRowsAsVector4(row => {
            if (rowcount!=1 && rowcount!=canvasDimensionLength){
                for (int x=1 ; x < row.Length-1 ; x++){
                    pixelRowLength = row.Length;
                    inputList.Add((float)(1- (0.299 * row[x].X + 0.587 * row[x].Y + 0.114 * row[x].Z)));
                }

            }
            rowcount++;
        }));

        var greatestPixelValue = (inputList.Max() != 0) ? -1 : inputList.Max();
        inputList.ForEach(pixel => pixel = pixel / greatestPixelValue);

        NoughtToNine.ModelInput input = new(){ Pixels = inputList.ToArray() };

        pixelArrayDims = input.Pixels.Length;
        nonMinMaxPixelCount = input.Pixels.Count(pixel => pixel > 0.1);


        var predictionEngine = 
            MLContext.Model.CreatePredictionEngine<NoughtToNine.ModelInput, NoughtToNine.ModelOutput>
            (Transformer, inputSchemaDefinition: Microsoft.ML.Data.SchemaDefinition.Create(typeof(NoughtToNine.ModelInput)));

        NoughtToNine.ModelOutput output = null;
        predictionEngine.Predict(input, ref output);

        this.Prediction = output.PredictedLabel;
    }

    protected async Task ExportImage(MouseEventArgs mea){
        this.dataURL = await JS.InvokeAsync<string>(
            "MyCanvasGetDataURL", 
            this._canvasReference.CanvasReference
            );

        var imageURL = Convert.FromBase64String(dataURL.Replace("data:image/png;base64,", string.Empty));

        StreamWriter sr = new StreamWriter(imageLocation);
        BinaryWriter br = new BinaryWriter(sr.BaseStream);
        br.Write(imageURL);
        sr.Dispose();
        br.Dispose();
    }

    protected async Task CanvasClick(MouseEventArgs mea){        
        var boundRect = await JS.InvokeAsync<BoundingClientRect>(
            "MyDOMGetBoundingClientRect", 
            this._canvasReference.CanvasReference
            );

        var floatingClickpointX = mea.ClientX - boundRect.Left;
        var floatingClickpointY = mea.ClientY - boundRect.Top;

        if (floatingClickpointX > 0 && canvasDimensionLength > floatingClickpointX){
            this.mouseX = floatingClickpointX;
        }
        else{
            this.mouseX = null;
        }

        if (floatingClickpointY > 0 && canvasDimensionLength > floatingClickpointY){
            this.mouseY = floatingClickpointY;
        }
        else{
            this.mouseY = null;
        }

        if (this.mouseX == null || this.mouseY == null){
            return;
        }

        double X = this.mouseX ?? -1;
        double Y = this.mouseY ?? -1;

        // await this._context.FillRectAsync(X - 5 , Y - 5, 10, 10);
        if (mouseXCache is null || mouseYCache is null){
            await this._context.BeginPathAsync();
            await this._context.MoveToAsync(X, Y);
        }
        else{
            await this._context.LineToAsync(X, Y);
            await this._context.StrokeAsync();
        }

        mouseXCache = X;
        mouseYCache = Y;
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender){
            this._context = await this._canvasReference.CreateCanvas2DAsync();

            await this._context.SetFillStyleAsync("black");
            await this._context.FillRectAsync(0, 0, canvasDimensionLength, canvasDimensionLength);

            await this._context.SetFillStyleAsync("white");
            await this._context.FillRectAsync(1, 1, imageDimensionLength, imageDimensionLength);

            await this._context.SetFillStyleAsync("black");

            await this._context.SetStrokeStyleAsync("black");
            await this._context.SetLineWidthAsync(2);
        }
    }

    public class BoundingClientRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Left { get; set; }
    }
}