@page "/The_Eye"
@using Microsoft.ML
@inject IJSRuntime JS

<PageTitle>The Eye</PageTitle>

<h1>Go on, just try and draw a 1-digit number</h1>

<div tabindex="0" @onmousedown="CanvasMouseDown" @onmouseup="CanvasMouseUp">
    <BECanvas Width="@canvasDimensionLength" Height="@canvasDimensionLength" @ref="_canvasReference"></BECanvas>
</div>

<button @onclick="PredictImage">Predict Image</button>

<p>I think that's a @Prediction</p>

@code {
    private bool mouseHeld = false;
    
    private int drawAreaPixelLength = 28;
    
    private int borderWidth = 1;

    private int canvasPixelLength => drawAreaPixelLength + 2*borderWidth;

    private int imageDimensionLength => drawAreaPixelLength * canvasScale;

    private int canvasDimensionLength => canvasPixelLength * canvasScale;

    private int canvasScale = 10;

    private double? mouseX;

    private double? mouseXCache;

    private double? mouseY;

    private double? mouseYCache;

    private string dataURL = string.Empty;

    private const string imageLocation = "images/canvasImage.png";

    private const string intermediateImageLocation = "images/shrunkCanvasImage.png";
    
    private const string csvLocation = "images/canvasImage.csv";

    private Canvas2DContext _context;

    protected BECanvasComponent _canvasReference;

    protected bool CanvasLoaded = false;

    protected ITransformer Transformer = NoughtToNine.TheModel.Transformer;

    protected MLContext MLContext = NoughtToNine.TheModel.mlContext;

    protected UInt32 Prediction = 10;

    protected async Task PredictImage(){
        await ExportImage(null);

        Image image = SixLabors.ImageSharp.Image.Load(new StreamReader(imageLocation).BaseStream);
        image.Mutate(x => x.Crop(Rectangle.FromLTRB(
            borderWidth*canvasScale,
            borderWidth*canvasScale,
            canvasDimensionLength - borderWidth*canvasScale,
            canvasDimensionLength - borderWidth*canvasScale
            )));
        image.Mutate(x => x.Resize(drawAreaPixelLength, drawAreaPixelLength));

        image.Save(intermediateImageLocation);

        List<float> inputList = new();

        image.Mutate(c => c.ProcessPixelRowsAsVector4(row => {
            for (int x = 0 ; x < row.Length ; x ++){
                inputList.Add((float) (1- (0.299 * row[x].X + 0.587 * row[x].Y + 0.114 * row[x].Z)));
            }
        }));

        var greatestPixelValue = (inputList.Max() != 0) ? -1 : inputList.Max();
        inputList.ForEach(pixel => pixel = pixel / greatestPixelValue);

        NoughtToNine.ModelInput input = new(){ Pixels = inputList.ToArray() };
        
        var predictionEngine = 
            this.MLContext.Model.CreatePredictionEngine<NoughtToNine.ModelInput, NoughtToNine.ModelOutput>
            (this.Transformer, inputSchemaDefinition: Microsoft.ML.Data.SchemaDefinition.Create(typeof(NoughtToNine.ModelInput)));

        NoughtToNine.ModelOutput output = null;

        //this.Prediction = (UInt32) input.Pixels.Length;

        predictionEngine.Predict(input, ref output);

        this.Prediction = output.PredictedLabel;
    }

    protected async Task DrawAsync(double X, double Y){
        if (X > 0 && canvasDimensionLength > X){
            this.mouseX = X;
        }
        else{
            this.mouseX = null;
        }

        if (Y > 0 && canvasDimensionLength > Y){
            this.mouseY = Y;
        }
        else{
            this.mouseY = null;
        }

        if (this.mouseX == null || this.mouseY == null){
            mouseXCache = mouseX;
            mouseYCache = mouseY;
            return;
        }

        double nonnullX = this.mouseX ?? -1;
        double nonnullY = this.mouseY ?? -1;

        // await this._context.FillRectAsync(X - 5 , Y - 5, 10, 10);
        if (mouseXCache is null || mouseYCache is null){
            await this._context.BeginPathAsync();
            await this._context.MoveToAsync(nonnullX, nonnullY);
        }
        else{
            await this._context.LineToAsync(nonnullX, nonnullY);
            await this._context.StrokeAsync();
        }

        mouseXCache = nonnullX;
        mouseYCache = nonnullY;
    }

    protected async Task ExportImage(MouseEventArgs mea){
        this.dataURL = await JS.InvokeAsync<string>(
            "MyCanvasGetDataURL", 
            this._canvasReference.CanvasReference
            );

        var imageURL = Convert.FromBase64String(dataURL.Replace("data:image/png;base64,", string.Empty));

        StreamWriter sr = new StreamWriter(imageLocation);
        BinaryWriter br = new BinaryWriter(sr.BaseStream);
        br.Write(imageURL);
        sr.Dispose();
        br.Dispose();
    }

    protected async Task CanvasMouseUp(MouseEventArgs mea){
        mouseHeld = false;
    }

    protected async Task CanvasMouseDown(MouseEventArgs mea){
        mouseHeld = true;

        while (mouseHeld){
            await CanvasClick(mea);
        }
    }

    protected async Task CanvasClick(MouseEventArgs mea){        
        var boundRect = await JS.InvokeAsync<BoundingClientRect>(
            "MyDOMGetBoundingClientRect", 
            this._canvasReference.CanvasReference
            );

        var floatingClickpointX = mea.ClientX - boundRect.Left;
        var floatingClickpointY = mea.ClientY - boundRect.Top;

        await DrawAsync(floatingClickpointX, floatingClickpointY);
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender){
            this._context = await this._canvasReference.CreateCanvas2DAsync();

            await this._context.SetFillStyleAsync("black");
            await this._context.FillRectAsync(0, 0, canvasDimensionLength, canvasDimensionLength);

            await this._context.SetFillStyleAsync("white");
            await this._context.FillRectAsync(borderWidth*canvasScale, borderWidth*canvasScale, imageDimensionLength, imageDimensionLength);

            await this._context.SetFillStyleAsync("black");

            await this._context.SetStrokeStyleAsync("black");
            await this._context.SetLineWidthAsync(canvasScale);
        }
    }

    public class BoundingClientRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Left { get; set; }
    }
}